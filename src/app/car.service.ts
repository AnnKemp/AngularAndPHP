// this service is generated by the CLI: ng generate service car -- flat --skipTests  see info at: angular.io/cli/generate#service-command
import { Injectable } from '@angular/core';
import { HttpClient, HttpErrorResponse, HttpParams } from "@angular/common/http";

import { Observable, throwError } from "rxjs";
import { map, catchError } from "rxjs/operators";

import { Car } from './car';

@Injectable({ // the injectable decorator allows the service to participate in the dependency injection system. Which means that on the one hand, it can have dependencies (i.e., the HttpClientModule module), and on the other hand, it can be injected, for example into the components.
  // What is a dependency? A dependency is when one class depends on another for its function
  providedIn: 'root'
})
export class CarService { // when developing with Angular it is strongly advised to use the Dependency Injection system to manage the objects that the class needs.
  baseUrl='http://localhost/api';
  cars: Car[];

  constructor(private http: HttpClient) { // the dependency injection is done in the constructor, by defining the private http var as beloning to the HttpClient type, which instructs Angular to handle the creation of the HttpClient object for us by using the dependency injection.

 // Importing from the RxJS library allows us to work with the Observable that Angular wraps around the data that is coming from the server. Using an Observable instead of a standard callback to handle asynchornous code offers serveral advantages, including multiple operators that facilitate data handling, as well as the ability to listen to data that the server emits repeatedly over time.
  }
  // the getAll() method returns the list of cars wrapped in an Observable
  getAll(): Observable<Car[]>{
       return this.http.get('${this.baseUrl}/list').pipe(map((res)=>{
         this.cars=res['data'];
         return this.cars;
    }),
      catchError(this.handleError));
  }
  private handleError(error:HttpErrorResponse){
      console.log(error);

      // return an observable with a user friendly message
    return throwError ('Error! something went wrong.');
  }
}       // hier was ik bezig, de haakjes nog een nakijken en die cars var moet ergens vandaan komen via die service en momenteel werkt dat niet.

